<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<title>Achievements</title>
<style>
html, body {
user-select: none;
overflow-y: auto;
overflow-x: hidden;
height: 100vh;
}
body::-webkit-scrollbar {
display: none;
}
button,
input,
textarea,
select {
-webkit-app-region: no-drag;
}
table {
width: 90%;
border-collapse: collapse;
}
table, th, td {
margin-top: 20px;
border: 1px solid black;
}

.displayName {			
padding-left: 15px;
}
.description {
padding-left: 25px;
}
.image {
padding-top: 5px;
text-align: center;
}
img {
width: 100px;
height: auto;
align-self: center;
}
#config-list {
margin-top: 10px;
margin-bottom: 20px; 
}
button {
margin-top: 10px; 
margin-bottom: 20px;
}
label {
margin-top: 10px; 
margin-bottom: 20px; 
}
.status {
text-align: center;
vertical-align: middle;
font-size: 14px;
}
.locked { color: red; font-weight: bold; }
.unlocked { color: green; font-weight: bold; }

</style>
</head>
<body>
<!-- Modern Titlebar -->
<div class="titlebar">
  <div class="titlebar-logo">
    <img src="icon.ico" alt="App Icon">
    <span class="titlebar-title">Achievements</span>
  </div>
  <div class="titlebar-controls">
    <button id="settingsBtn" class="titlebar-button">
      <i class="fas fa-cog"></i>
    </button>
    <button id="minimizeBtn" class="titlebar-button">
      <i class="fas fa-minus"></i>
    </button>
    <button id="maximizeBtn" class="titlebar-button">
      <i class="far fa-square"></i>
    </button>
    <button id="closeBtn" class="titlebar-button close">
      <i class="fas fa-times"></i>
    </button>
  </div>
</div>

<!-- Settings Menu Panel -->
<div id="settingsMenu" class="settings-menu hidden">
  <div class="settings-content" tabindex="-1">
    <button class="settings-close-button" id="closeSettingsBtn">&times;</button>
    
    <div class="settings-tabs">
      <h3 style="margin: 0 0 15px 10px; color: var(--dracula-purple);">Settings</h3>
      <button class="settings-tab active" data-tab="general">General</button>
      <button class="settings-tab" data-tab="notification">Notification</button>
    </div>
    
    <div class="settings-tabs-content">
      <div id="generalTab" class="tab-content active">
        <div style="padding: 0 5px;">
          <div class="settings-section">
            <h4>App Scale</h4>
            <div class="settings-control">
              <label for="app-zoom-dropdown">Zoom Level:</label>
              <select id="app-zoom-dropdown">
                <option value="0.75">75%</option>
                <option value="1" selected>100%</option>
                <option value="1.25">125%</option>
                <option value="1.5">150%</option>
                <option value="2">200%</option>
              </select>
            </div>
          </div>
          <div class="settings-section">
            <h4>Overlay Shortcut</h4>
            <div class="settings-control">
              <label for="overlay-shortcut-btn">Shortcut Key:</label>
              <button id="overlay-shortcut-btn" type="button">Set Shortcut</button>
            </div>
          </div>
        </div>
      </div>
      
      <div id="notificationTab" class="tab-content">
        <div style="padding: 0 5px;">
          <div class="settings-section">
            <h4>Achievement Testing</h4>
            <button id="settings-testAchievementBtn" class="settings-test-button" style="width: 100%; margin: 10px 0; padding: 10px;">Test Achievement</button>
            
            <div class="checkbox-control">
              <input type="checkbox" id="settings-disableProgressCheckbox" />
              <label for="settings-disableProgressCheckbox">Disable Progress Report</label>
            </div>
            
            <div class="settings-slider">
              <label for="settings-scaleSlider">Achievement Scale: <span id="settings-scaleValue">1.0</span></label>
              <div class="slider-control">
                <input type="range" id="settings-scaleSlider"
                  min="0.01" max="2.0" step="0.01" value="1.0" />
                <span class="value" id="settings-scaleValueDisplay">100%</span>
              </div>
            </div>
            
            <div class="settings-control">
              <label for="settings-positionDropdown">Achievement Position:</label>
              <select id="settings-positionDropdown">
                <option value="center-bottom">Center Bottom</option>
                <option value="center-top">Center Top</option>
                <option value="top-right">Top Right</option>
                <option value="bottom-right">Bottom Right</option>
                <option value="top-left">Top Left</option>
                <option value="bottom-left">Bottom Left</option>
              </select>
            </div>
            
            <div class="settings-control">
              <label for="settings-presetDropdown">Achievement Presets:</label>
              <select id="settings-presetDropdown"></select>
            </div>
            
            <div class="settings-control">
              <label for="settings-soundSelect">Achievement Sound:</label>
              <select id="settings-soundSelect"></select>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="top-bar">
  <div id="left-controls" style="margin-left: 10px; position: relative; display: flex; flex-direction: column; align-items: flex-start; gap: 10px;">
    <!-- Remove the zoom dropdown from here since it's now in the settings menu -->
  </div>
</div>

<div class="container">
  <div id="left-controls" style="position: relative; display: flex; flex-direction: column; align-items: flex-start; gap: 10px;">
    <!-- Shortcut input button removed -->
  </div>
<!-- Toggle Settings Button -->
<div style="margin-bottom: 10px; position: relative; display: flex; align-items: center; gap: 10px;">
<button id="toggleBtn">Show Settings</button>

<!-- Progres bar -->
<div id="achStats" style="
display: none;
position: absolute;
left: 50%;
transform: translateX(-50%);
text-align: center;
width: 320px;
z-index: 10;
margin-top: -30px;
">
<label id="achStatsText" style="color: white; font-weight: bold;">Progress: 0 / 0</label>
<div style="width: 100%; background: #ccc; border-radius: 8px; height: 12px; margin-top: -10px; position: relative;">
<div id="achStatsBar" style="width: 0%; height: 100%; background: #4caf50; border-radius: 8px; transition: width 0.3s;"></div>
<span id="achStatsPercent" style="
position: absolute;
right: 5px;
top: -22px;
font-size: 12px;
color: white;
font-weight: bold;
">0%</span>
</div>
</div>

<button id="playBtn" style="margin-left: auto;"><i class="fas fa-play"></i> Play</button>
</div>



<div id="gameImageContainer" style="margin-bottom: 20px; display: none;">
<img id="gameImage" src="" alt="Game Cover"
style="width: 120px; border-radius: 10px; box-shadow: 0 0 8px rgba(0,0,0,0.3);">
</div>

<!-- Toggleable Settings Container -->
<div id="buttonContainer" class="hidden config-container" style="display: none; justify-content: space-between; gap: 15px;">

<!-- Left Side: Create Config and Select Config -->
<div class="left-config" style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 5px;">
<div>
<div style="display: flex; gap: 20px;">
  <button id="createNewConfigBtn" style="flex: 1; padding: 10px;">
    Create New Config <span id="arrowIcon">▼</span>
  </button>
  
  <button id="generateConfigsBtn" style="flex: 1; padding: 10px;">
    Generate Auto-Configs
  </button>
</div>



<div id="configModal" class="modal hidden">
<div class="modal-content">
<span class="close-button" id="closeConfigModal">&times;</span>
<h2 id="configFormTitle" style="margin-top: 0;">Config Form</h2>

<div id="new-config-form" style="display: flex; flex-direction: column; gap: 14px; margin-top: -10px;">
<div style="display: flex; gap: 20px;">
<!-- Right -->
<div style="flex: 1; display: flex; flex-direction: column;">
<label for="configName">Config Name:</label>
<input type="text" id="configName" placeholder="Enter Config Name *">

<label for="appid">AppID:</label>
<input type="text" id="appid" placeholder="Enter AppID *">

<label for="configPath">Config path:</label>
<div class="input-with-button">
<input type="text" id="configPath" placeholder="Select config folder path *">
<button type="button" id="selectConfigFolder">📂</button>
</div>

<label for="savePath">Save path:</label>
<div class="input-with-button">
<input type="text" id="savePath" placeholder="Select save folder path *">
<button type="button" id="selectSaveFolder">📂</button>
</div>
</div>

<!-- Left -->
<div style="flex: 1; display: flex; flex-direction: column; ">
<label for="executablePath">Executable (optional):</label>
<div class="input-with-button">
<input type="text" id="executablePath" placeholder="Path to executable">
<button type="button" id="selectExecutable">📂</button>
</div>

<label for="exeArgs">Arguments (optional):</label>
<input type="text" id="exeArgs" placeholder="Optional arguments">

<label for="processName">Process name (optional):</label>
<input type="text" id="processName" placeholder="Optional – real .exe name">
</div>
</div>

<!-- Buton Save -->
<div style="display: flex; justify-content: center; margin-top: 5px;">
<button id="saveBtn" style="background-color: #4CAF50; color: white; border: none; padding: 10px 24px; border-radius: 6px; font-weight: bold; width: auto;">
Save Config
</button>
</div>
</div>
</div>
</div>

</div>

<div class="config-controls" style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 5px;">
<label for="configList">Select Config:</label>
<select id="configList" style="width: 100%; margin-top: -15px;">
<option value="" disabled selected>Select</option>
</select>
<div>
<button id="deleteConfigBtn" style="display: none; width: 100%; margin-top: 5px;">Delete</button>
<div style="display: flex; width: 100%; margin-top: 15px; gap: 10px;  margin-bottom: 5px;">
<button id="backButton" class="hidden">Back</button>
<button id="editConfigBtn" style="display: none;">Edit Config</button>
</div>

</div>
<div class="language-controls" style="width: 100%; margin-top: -22px;">
<label for="langList"style="width: 100%; margin-top: 11px;">Select Language:</label>
<select id="languageSelect" >
<option value="english">English</option>
<option value="german">Deutsch</option>
<option value="french">Français</option>
<option value="italian">Italiano</option>
<option value="koreana">한국어 (Korean)</option>
<option value="spanish">Español</option>
<option value="schinese">简体中文 (Chinese - Simplified)</option>
<option value="tchinese">繁體中文 (Chinese - Traditional)</option>
<option value="russian">Русский</option>
<option value="japanese">日本語</option>
<option value="polish">Polski</option>
<option value="brazilian">Português (Brasil)</option>
<option value="LATAM">Español (Latinoamérica)</option>
</select>
</div>
<button id="toggleImageBtn"style="width: 100%; margin-top: 45px;">⇦ Show Game Image</button>			
</div>

</div>

<!-- Right Side: Test Achievement + Dropdowns -->
<div class="settings-container" style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 5px;">
  <!-- Content removed as it's now in the settings modal -->
</div>
</div>
</div>

<div class="scroll-container">
<table class="achievements">
<thead><tr></tr></thead>
<tbody id="achievementsTableBody"></tbody>
</table>
<div style="height: 50px;"></div>
</div>

<!-- Hidden elements to maintain compatibility with existing code -->
<div style="display: none;">
  <button id="testAchievementBtn">Test Achievement</button>
  <input type="checkbox" id="disableProgressCheckbox" />
  <input type="range" id="scaleSlider" min="0.01" max="2.0" step="0.01" value="1.0" />
  <span id="scaleValue">1.0</span>
  <select id="positionDropdown">
    <option value="center-bottom">Center Bottom</option>
    <option value="center-top">Center Top</option>
    <option value="top-right">Top Right</option>
    <option value="bottom-right">Bottom Right</option>
    <option value="top-left">Top Left</option>
    <option value="bottom-left">Bottom Left</option>
  </select>
  <select id="presetDropdown"></select>
  <select id="soundSelect"></select>
</div>

<script>
document.getElementById('toggleImageBtn').addEventListener('click', async () => {
const selectedConfigName = document.getElementById('configList').value;
const toggleBtn = document.getElementById('toggleImageBtn');

if (!selectedConfigName) {
alert('Please select a config first!');
return;
}

const config = await window.api.getConfigByName(selectedConfigName);
const appid = config?.appid;

if (!appid) {
alert('This config has no AppID set!');
return;
}

const currentText = toggleBtn.textContent.trim();

if (currentText.includes('Show')) {
await window.api.openGameImageWindow(appid, 'user');
toggleBtn.textContent = '⇨ Hide Game Image';
} else {
await window.api.closeImageWindow();
toggleBtn.textContent = '⇦ Show Game Image';
}
});

window.api.onImageWindowStatus?.((status) => {
const toggleBtn = document.getElementById('toggleImageBtn');
toggleBtn.textContent = status.isVisible ? '⇨ Hide Game Image' : '⇦ Show Game Image';
});


const notificationQueue = [];
let isNotificationActive = false;

function showNotification(message, backgroundColor = '#4CAF50') {
notificationQueue.push({ message, backgroundColor });
if (!isNotificationActive) {
processNextNotification();
}
}

function processNextNotification() {
if (notificationQueue.length === 0) {
isNotificationActive = false;
return;
}

document.getElementById('disableProgressCheckbox').addEventListener('change', async (e) => {
const isChecked = e.target.checked;
window.api.disableProgress(isChecked);
await window.api.savePreferences({ disableProgress: isChecked });
});


isNotificationActive = true;
const { message, backgroundColor } = notificationQueue.shift();

const notif = document.createElement('div');
notif.textContent = message;
notif.style.position = 'fixed';
notif.style.top = '100px';
notif.style.left = '50%';
notif.style.transform = 'translateX(-50%)';
notif.style.backgroundColor = backgroundColor;
notif.style.color = 'white';
notif.style.padding = '10px 20px';
notif.style.borderRadius = '5px';
notif.style.boxShadow = '0px 2px 8px rgba(0,0,0,0.3)';
notif.style.zIndex = 9999;
notif.style.fontWeight = 'bold';
notif.style.fontFamily = 'sans-serif';
notif.style.opacity = '0';
notif.style.transition = 'opacity 0.3s ease';
notif.style.pointerEvents = 'none';
notif.style.userSelect = 'none';
document.body.appendChild(notif);
requestAnimationFrame(() => notif.style.opacity = '1');

setTimeout(() => {
notif.style.opacity = '0';
setTimeout(() => {
notif.remove();
processNextNotification();
}, 300); 
}, 4000); 
}

window.api.onNotify(({ message, color }) => {
showNotification(message, color || '#4CAF50');
});

window.addEventListener('DOMContentLoaded', () => {
const originalLog = console.log;
const originalWarn = console.warn;
const originalError = console.error;
const originalAlert = window.alert;

console.log = function (...args) {
originalWarn.apply(console, args);
showNotification(args.join(' '), '#4CAF50');
};

console.warn = function (...args) {
originalWarn.apply(console, args);
showNotification(args.join(' '), '#ff9800');
};

console.error = function (...args) {
originalError.apply(console, args);
showNotification(args.join(' '), '#f44336');
};

window.alert = function (message) {
showNotification(message, '#2196f3');
};
});

const scaleSlider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');

function updateScaleLabel() {
const value = parseFloat(scaleSlider.value);
scaleValue.textContent = `${Math.round(value * 100)}%`;
scaleSlider.style.background = `linear-gradient(to right, #007bff 0%, #007bff ${value * 100}%, #ccc ${value * 100}%, #ccc 100%)`;
}
scaleSlider.addEventListener('input', () => {
updateScaleLabel();
window.api.savePreferences({ notificationScale: scaleSlider.value });
});
updateScaleLabel();


window.addEventListener('DOMContentLoaded', () => {
const minimizeBtn = document.getElementById('minimizeBtn');
const maximizeBtn = document.getElementById('maximizeBtn');
const closeBtn = document.getElementById('closeBtn');

document.getElementById('closeConfigModal').addEventListener('click', () => {
document.getElementById('configModal').classList.add('hidden');
resetConfigForm();
});
});

let editingConfigName = null;

function resetConfigForm() {
const form = document.getElementById('new-config-form');
const button = document.getElementById('createNewConfigBtn');
document.getElementById('configName').value = '';
document.getElementById('appid').value = '';
document.getElementById('configPath').value = '';
document.getElementById('savePath').value = '';
document.getElementById('executablePath').value = '';
document.getElementById('exeArgs').value = '';
document.getElementById('processName').value = '';

editingConfigName = null;

if (!form.classList.contains('hidden')) {
form.classList.add('hidden');
}

button.innerHTML = 'Create New Config <span id="arrowIcon">▼</span>';
document.getElementById('configFormTitle').textContent = 'Create New Config';
}

document.getElementById('createNewConfigBtn').addEventListener('click', () => {
resetConfigForm();
document.getElementById('configModal').classList.remove('hidden');
document.getElementById('new-config-form').classList.remove('hidden');
document.getElementById('configFormTitle').textContent = 'Create New Config';
});

document.getElementById('editConfigBtn').addEventListener('click', async () => {
const configName = document.getElementById('configList').value;
if (!configName) return;

try {
const currentConfig = await window.api.getConfigByName(configName);

if (!currentConfig) {
alert('Config not found!');
return;
}

document.getElementById('configName').value = currentConfig.name;
document.getElementById('appid').value = currentConfig.appid;
document.getElementById('configPath').value = currentConfig.config_path;
document.getElementById('savePath').value = currentConfig.save_path;
document.getElementById('executablePath').value = currentConfig.executable || '';
document.getElementById('exeArgs').value = currentConfig.arguments || '';
document.getElementById('processName').value = currentConfig.process_name || '';

editingConfigName = currentConfig.name;
const form = document.getElementById('new-config-form');
if (form.style.display !== 'block') {
document.getElementById('configModal').classList.remove('hidden');

}
const button = document.getElementById('createNewConfigBtn');

form.classList.remove('hidden');
button.innerHTML = 'Editing... <span id="arrowIcon" class="rotate-up">▲</span>';
document.getElementById('configFormTitle').textContent = 'Edit Config';

} catch (err) {
console.error('Edit error:', err);
alert('Something went wrong loading the config.');
}
});

document.getElementById('selectConfigFolder').addEventListener('click', async () => {
const selectedPath = await window.api.selectFolder();
if (selectedPath) {
document.getElementById('configPath').value = selectedPath;
}
});

document.getElementById('selectSaveFolder').addEventListener('click', async () => {
const selectedPath = await window.api.selectFolder();
if (selectedPath) {
document.getElementById('savePath').value = selectedPath;
}
});

document.getElementById('saveBtn').addEventListener('click', async () => {
const configName = document.getElementById('configName').value;
const appid = document.getElementById('appid').value;
const configPath = document.getElementById('configPath').value;
const savePath = document.getElementById('savePath').value;
const executable = document.getElementById('executablePath').value;
const arguments = document.getElementById('exeArgs').value;		 
const processName = document.getElementById('processName').value;

if (!configName || !appid || !configPath || !savePath) {
const notif = document.createElement('div');
notif.textContent = 'All fields are mandatory!';
notif.style.position = 'fixed';
notif.style.top = '100px';
notif.style.left = '50%';
notif.style.transform = 'translateX(-50%)';
notif.style.backgroundColor = '#f44336';
notif.style.color = 'white';
notif.style.padding = '10px 20px';
notif.style.borderRadius = '5px';
notif.style.boxShadow = '0px 2px 8px rgba(0,0,0,0.3)';
notif.style.zIndex = 9999;
notif.style.fontWeight = 'bold';
notif.style.fontFamily = 'sans-serif';

document.body.appendChild(notif);
setTimeout(() => notif.remove(), 3000);
return;
}

const config = {
name: configName,
appid: appid,
config_path: configPath,
save_path: savePath,
executable: executable || null,
arguments: arguments || '',
process_name: processName || ''
};

const result = editingConfigName && editingConfigName !== configName
? await window.api.renameAndSaveConfig(editingConfigName, config)
: await window.api.saveConfig(config);

showNotification(result.message, result.success ? '#4CAF50' : '#f44336');

if (result.success) {
editingConfigName = null;
document.getElementById('createNewConfigBtn').innerText = 'Create New Config';
localStorage.setItem('configSavedMessage', result.message);
localStorage.setItem('configSavedSuccess', result.success ? 'true' : 'false');

window.location.reload();
}

});


document.getElementById("toggleBtn").addEventListener("click", function () {
let container = document.getElementById("buttonContainer");
if (container.classList.contains("hidden")) {
container.classList.remove("hidden");
  container.style.display = "flex";
this.textContent = "Hide Settings";
} else {
container.classList.add("hidden");
  container.style.display = "none";
this.textContent = "Show Settings";
}
});

document.getElementById('selectExecutable').addEventListener('click', async () => {
const selectedExe = await window.api.selectExecutable(); // adaugi această funcție în preload și main
if (selectedExe) {
document.getElementById('executablePath').value = selectedExe;
}
});

document.getElementById('playBtn').addEventListener('click', async () => {
const config = await window.api.getConfigByName(configList.value);
if (config && config.executable) {
const args = config.arguments || '';
await window.api.launchExecutable(config.executable, args);
}
});




document.getElementById('languageSelect').addEventListener('change', async (e) => {
const selectedLang = e.target.value;

await window.api.savePreferences({ language: selectedLang });

const configName = document.getElementById('configList').value;
window.api.refreshUILanguage({ language: selectedLang, configName });


localStorage.setItem('preferredLanguage', selectedLang);
});

const savedLang = localStorage.getItem('preferredLanguage') || 'english';
document.getElementById('languageSelect').value = savedLang;
function getLocalizedText(obj, lang = 'english') {
if (!obj) return '';
if (typeof obj === 'string') return obj;
return obj[lang] || obj['english'] || '';
}


const presetDropdown = document.getElementById('presetDropdown');
const positionDropdown = document.getElementById('positionDropdown');
const configList = document.getElementById('configList');

function updateMainConfig() {
const selectedConfig = configList.value;
const preset = presetDropdown.value;
const position = positionDropdown.value;

if (selectedConfig) {
window.api.updateConfig({
configName: selectedConfig,
preset: preset,
position: position
});
}
}


presetDropdown.addEventListener('change', updateMainConfig);

positionDropdown.addEventListener('change', updateMainConfig);

configList.addEventListener('change', updateMainConfig);

function getSafeLocalizedText(input, lang = 'english') {
if (!input) return 'Hidden';
if (typeof input === 'string') return input.trim() || 'Hidden';
if (typeof input === 'object') {
return input[lang] || input.english || 
Object.values(input).find(v => typeof v === 'string' && v.trim() !== '') || 
'Hidden';
}
return 'Hidden';
}


window.addEventListener('DOMContentLoaded', async () => {
const configs = await window.api.loadConfigs();
const configList = document.getElementById('configList');
configs.forEach(config => {
const option = document.createElement('option');
option.value = config;
option.textContent = config;
configList.appendChild(option);
});

function formatTimestamp(timestamp) {
if (!timestamp) return "N/A";
const date = new Date(timestamp * 1000);
return date.toLocaleString();
}

configList.addEventListener('change', async () => {
const selectedConfig = configList.value;

if (selectedConfig) {
window.api.updateConfig({
configName: selectedConfig,
preset: presetDropdown.value,
position: positionDropdown.value
});
}



const achievementsDataObj = await window.api.loadAchievementData(selectedConfig);
const savedAchievementsObj = await window.api.loadSavedAchievements(selectedConfig);
const currentConfig = await window.api.getConfigByName(selectedConfig);
if (currentConfig && currentConfig.appid) {
}
if (currentConfig?.appid) {
const result = await window.api.openGameImageWindow(currentConfig.appid, 'user');
const toggleBtn = document.getElementById('toggleImageBtn');
toggleBtn.textContent = result.isVisible ? '⇨ Hide Game Image' : '⇦ Show Game Image';
}

const playBtn = document.getElementById('playBtn');
playBtn.style.display = currentConfig?.executable ? 'inline-block' : 'none';

const tableBody = document.querySelector('#achievementsTableBody');
if (tableBody) {
tableBody.innerHTML = '';
} else {
console.error('tableBody could not be found.');
return;
}

if (achievementsDataObj.error) {
alert(achievementsDataObj.error);
return;
}

if (!Array.isArray(achievementsDataObj.achievements)) {
console.error('Data syntax incorrect');
return;
}

const lang = document.getElementById('languageSelect').value;

for (const achievement of achievementsDataObj.achievements) {
const displayName = getSafeLocalizedText(achievement.displayName, lang);
const description = getSafeLocalizedText(achievement.description, lang);
const iconGray = achievement.icon_gray || achievement.icongray;
const icon = achievement.icon || iconGray;

let imagePath = `${achievementsDataObj.config_path}\\${iconGray}`;
let status = `<span style="color: red; font-weight: bold;">Locked</span>`;
let earnedTimeText = "";
let progressText = "";

if (
savedAchievementsObj &&
savedAchievementsObj.achievements &&
savedAchievementsObj.achievements[achievement.name] &&
savedAchievementsObj.achievements[achievement.name].earned
) {
imagePath = `${achievementsDataObj.config_path}\\${icon}`;
status = `<span style="color: green; font-weight: bold;">Unlocked</span>`;
earnedTimeText = `<br>${formatTimestamp(savedAchievementsObj.achievements[achievement.name].earned_time)}`;
}

if (savedAchievementsObj?.achievements?.[achievement.name]) {
const saved = savedAchievementsObj.achievements[achievement.name];
if (typeof saved.progress === 'number' && typeof saved.max_progress === 'number') {
progressText = `<br><span style="font-size: 0.85em; color: #888;">Progress: ${saved.progress} / ${saved.max_progress}</span>`;
}
}

const row = document.createElement('tr');
row.innerHTML = `
<td class="image">
<img src="file:///${imagePath.replace(/\\/g, "/")}" alt="Icon"
onerror="this.onerror=null; this.src='https://cdn-icons-png.flaticon.com/512/11455/11455431.png';" />
</td>
<td class="displayName"><strong>${displayName}</strong><br>
<span class="description"><em>${description}</em>${progressText}</span>
</td>
<td class="status">${status} ${earnedTimeText}</td>
`;
tableBody.appendChild(row);
}

updateAchievementStats(achievementsDataObj.achievements.map(a => {
const saved = savedAchievementsObj?.achievements?.[a.name];
return {
...a,
earned: saved?.earned || false
};
document.getElementById('achStats').style.display = 'block';

}));
});
});

window.addEventListener('DOMContentLoaded', async () => {
try {
const presetsData = await window.api.loadPresets();
const presetDropdown = document.getElementById('presetDropdown');
presetDropdown.innerHTML = '';

// Create category for presets that support scaling above 100%
const highScalingGroup = document.createElement('optgroup');
highScalingGroup.label = "⭐ Supports 200% Scaling";

// Create category for regular presets
const regularGroup = document.createElement('optgroup');
regularGroup.label = "Standard Presets (100% Max)";

// Check if we have the new structured format or old format
if (presetsData.isStructured) {
  // Handle new structured format with separate folders
  
  // Add scalable presets
  presetsData.scalable.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    highScalingGroup.appendChild(option);
  });
  
  // Add non-scalable presets
  presetsData.nonScalable.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    regularGroup.appendChild(option);
  });
} else {
  // Handle old format for backwards compatibility
  presetsData.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    
    // Add presets to their appropriate groups using the old logic
    if (preset === 'Modern' || preset === 'xqjan' || preset === 'Neon Future') {
      highScalingGroup.appendChild(option);
    } else {
      regularGroup.appendChild(option);
    }
  });
}

// Add groups to dropdown with enhanced scaling options first
presetDropdown.appendChild(highScalingGroup);
presetDropdown.appendChild(regularGroup);

} catch (error) {
console.error('Error loading presets:', error);
}
});


document.addEventListener('DOMContentLoaded', function () {
const testButton = document.getElementById('testAchievementBtn');
const configList = document.getElementById('configList');
const presetDropdown = document.getElementById('presetDropdown');
const positionDropdown = document.getElementById('positionDropdown');

let position = positionDropdown.value;

positionDropdown.addEventListener('change', function() {
position = positionDropdown.value;
});

testButton.addEventListener('click', async function() {
  const preset = presetDropdown.value || 'default';
  const position = positionDropdown.value;
  const sound = document.getElementById('soundSelect').value;
  const scale = parseFloat(document.getElementById('scaleSlider').value);
  
  window.api.showTestNotification({
    preset,
    position,
    sound,
    scale
  });
});

});
document.addEventListener('DOMContentLoaded', async function () {
async function loadConfigs() {
try {
const configs = await window.api.loadConfigs();
const configList = document.getElementById('configList');
configList.innerHTML = '<option value="" disabled selected>Select</option>';
configs.forEach(config => {
const option = document.createElement('option');
option.value = config;
option.textContent = config;
configList.appendChild(option);
});
} catch (error) {
console.error('Config Load Error:', error);
}
}
configList.addEventListener('change', function () {
deleteConfigBtn.style.display = configList.value ? 'inline-block' : 'none';
});

deleteConfigBtn.addEventListener('click', async function () {
const selectedConfig = configList.value;
if (!selectedConfig) return;

const confirmDelete = confirm(`Do you want to delete: ${selectedConfig}?`);
if (!confirmDelete) return;

try {
const response = await window.api.deleteConfig(selectedConfig);
if (response.success) {
await loadConfigs();
deleteConfigBtn.style.display = 'none';
} else {
console.error('Error on delete:', response.error);
}
} catch (error) {
console.error('Error on delete:', error);
}
});
});


window.api.onAchievementsMissing((configName) => {
showNotification(`⚠️ achievements.json not found in config: ${configName} config path` , '#f44336');
});

backButton.addEventListener('click', () => {
configList.value = '';
backButton.classList.add('hidden');
deleteConfigBtn.style.display = 'none';
document.getElementById('achStats').style.display = 'none';
window.api.closeImageWindow();
document.getElementById('toggleImageBtn').textContent = '⇦ Show Game Image';
});

document.getElementById('backButton').addEventListener('click', () => {
const configList = document.getElementById('configList');
configList.value = '';
document.getElementById('backButton').style.display = 'none';

const selectOption = configList.querySelector('option[value=""]');
if (selectOption) {
selectOption.selected = true;
selectOption.disabled = true;
}

document.getElementById('deleteConfigBtn').style.display = 'none';
document.getElementById('editConfigBtn').style.display = 'none';
document.getElementById('playBtn').style.display = 'none';
resetConfigForm();

const tableBody = document.getElementById('achievementsTableBody');
if (tableBody) tableBody.innerHTML = '';

window.api.updateConfig({ configName: null, preset: null, position: null });
window.api.toggleOverlay(null);
window.api.onLoadOverlayData(null);
if (window.api) {
window.api.closeImageWindow();
}
});

window.api.onToggleOverlayShortcut(() => {
  const selectedConfig = document.getElementById('configList').value;
  if (!selectedConfig) {
    alert('Select a config!');
    return;
  }
  window.api.toggleOverlay(selectedConfig);
});


configList.addEventListener('change', () => {
if (configList.value) {
backButton.classList.remove('hidden');
backButton.style.display = 'inline-block';
deleteConfigBtn.style.display = 'inline-block';
editConfigBtn.style.display = 'inline-block';
resetConfigForm();
}
});
window.onload = async () => {
const soundSelect = document.getElementById('soundSelect');

try {
const sounds = await window.api.getSounds();
const muteOption = document.createElement('option');
muteOption.value = 'mute';
muteOption.textContent = '🔇 Mute';
soundSelect.appendChild(muteOption);
sounds.forEach(sound => {
const option = document.createElement('option');
option.value = sound;
option.textContent = sound;
soundSelect.appendChild(option);
});
const prefs = await window.api.loadPreferences();
if (prefs && prefs.sound && soundSelect.querySelector(`option[value="${prefs.sound}"]`)) {
soundSelect.value = prefs.sound;
}
if (prefs.disableProgress !== undefined) {
  document.getElementById('disableProgressCheckbox').checked = prefs.disableProgress;
}
} catch (err) {
console.error("Sound Load Error:", err);
}
};


window.api.onPlaySound(async (soundName) => {
if (soundName && soundName !== 'mute') {
await playCustomSound(soundName);
}
});


function playSelectedSound() {
const soundSelect = document.getElementById('soundSelect');
const selectedSound = soundSelect?.value;

if (!selectedSound || selectedSound === 'mute') return;

const audio = new Audio(`sounds/${selectedSound}`);
audio.play().catch(err => {
console.error("⚠️ Sound play error:", err);
});
}

async function playCustomSound(fileName) {
if (!fileName || fileName === 'mute') return;

try {
const fullPath = await window.api.getSoundFullPath(fileName);
const audio = new Audio(fullPath);
audio.play().catch(err => {
console.error("⚠️ Custom sound play error:", err);
});
} catch (err) {
console.error("❌ Failed to load sound path:", err);
}
}

window.api.onRefreshAchievementsTable(async (event, configName) => {
const selectedLang = document.getElementById('languageSelect').value;
const lang = selectedLang;
const selectedConfig = configName || document.getElementById('configList').value;


if (!selectedConfig) {
console.warn('No config selected!');
return;
}

const achievementsDataObj = await window.api.loadAchievementData(selectedConfig);
const savedAchievementsObj = await window.api.loadSavedAchievements(selectedConfig);

const tableBody = document.querySelector('#achievementsTableBody');
if (tableBody) {
tableBody.innerHTML = '';
}

function formatTimestamp(timestamp) {
if (!timestamp) return "N/A";
const date = new Date(timestamp * 1000);
return date.toLocaleString();
}
achievementsDataObj.achievements.forEach(achievement => {
const row = document.createElement('tr');
const displayName = getSafeLocalizedText(achievement.displayName, lang);
const description = getSafeLocalizedText(achievement.description, lang);

const iconGray = achievement.icon_gray || achievement.icongray;
const icon = achievement.icon || iconGray;

let imagePath = `${achievementsDataObj.config_path}\\${iconGray}`;
let status = `<span style="color: red; font-weight: bold;">Locked</span>`;
let earnedTimeText = "";
let progressText = "";

if (
savedAchievementsObj &&
savedAchievementsObj.achievements &&
savedAchievementsObj.achievements[achievement.name] &&
savedAchievementsObj.achievements[achievement.name].earned
) {
imagePath = `${achievementsDataObj.config_path}\\${icon}`;
status = `<span style="color: green; font-weight: bold;">Unlocked</span>`;
earnedTimeText = `<br>${formatTimestamp(savedAchievementsObj.achievements[achievement.name].earned_time)}`;
}

if (savedAchievementsObj?.achievements?.[achievement.name]) {
const saved = savedAchievementsObj.achievements[achievement.name];
if (typeof saved.progress === 'number' && typeof saved.max_progress === 'number') {
progressText = `<br><span style="font-size: 0.85em; color: #888;">Progress: ${saved.progress} / ${saved.max_progress}</span>`;
}
}

row.innerHTML = `
<td class="image">
<img src="file:///${imagePath.replace(/\\/g, "/")}" alt="Icon"
onerror="this.onerror=null; this.src='https://cdn-icons-png.flaticon.com/512/11455/11455431.png';" /></td>
<td class="displayName"><strong>${displayName}</strong><br>
<span class="description"><em>${description}</em>${progressText}</span></td>
<td class="status">${status} ${earnedTimeText}</td>
`;
tableBody.appendChild(row);

updateAchievementStats(achievementsDataObj.achievements.map(a => {
const saved = savedAchievementsObj?.achievements?.[a.name];
return {
...a,
earned: saved?.earned || false
};
}));

});
});


async function loadPreferences() {
  const prefs = await window.api.loadPreferences();

  if (prefs.position) document.getElementById('positionDropdown').value = prefs.position;
  if (prefs.preset) document.getElementById('presetDropdown').value = prefs.preset;
  if (prefs.sound) document.getElementById('soundSelect').value = prefs.sound;
  if (prefs.notificationScale) {
    const scaleSlider = document.getElementById('scaleSlider');
    scaleSlider.value = prefs.notificationScale;
    updateScaleLabel();
  }
  if (prefs.disableProgress !== undefined) {
    const cb = document.getElementById('disableProgressCheckbox');
    if (cb) cb.checked = prefs.disableProgress;
  }
if (prefs.windowZoomFactor) {
  const zoomDropdown = document.getElementById('app-zoom-dropdown');
  if (zoomDropdown) {
    zoomDropdown.value = prefs.windowZoomFactor.toString();
    window.api.setZoom(prefs.windowZoomFactor); // <== Adaugă asta aici!
  }
}
if (prefs.overlayShortcut) {
  document.getElementById('overlay-shortcut-btn').textContent = prefs.overlayShortcut;
}
}



window.addEventListener('DOMContentLoaded', async () => {
try {
const prefs = await window.api.loadPreferences();
if (prefs) {
if (prefs.position) document.getElementById('positionDropdown').value = prefs.position;
if (prefs.preset) document.getElementById('presetDropdown').value = prefs.preset;
if (prefs.sound) document.getElementById('soundSelect').value = prefs.sound;
if (prefs.notificationScale) {
const scaleSlider = document.getElementById('scaleSlider');
scaleSlider.value = prefs.notificationScale;
updateScaleLabel();
}
if (prefs.disableProgress !== undefined) {
const cb = document.getElementById('disableProgressCheckbox');
if (cb) cb.checked = prefs.disableProgress;
}
if (prefs.windowZoomFactor) {
  const zoomDropdown = document.getElementById('app-zoom-dropdown');
  if (zoomDropdown) {
    zoomDropdown.value = prefs.windowZoomFactor.toString();
    window.api.setZoom(prefs.windowZoomFactor); // <== Adaugă asta aici!
  }
}
 if (prefs?.overlayShortcut) {
    document.getElementById('overlay-shortcut-btn').textContent = prefs.overlayShortcut;
  } else {
    document.getElementById('overlay-shortcut-btn').textContent = 'Set Shortcut';
  }
}
} catch (e) {
console.warn('Settings cannot be load:', e);
}
});

['positionDropdown', 'presetDropdown', 'soundSelect', 'languageSelect', 'scaleSlider', 'disableProgressCheckbox', 'app-zoom-dropdown'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('change', () => {
      const prefs = {
        position: document.getElementById('positionDropdown')?.value,
        preset: document.getElementById('presetDropdown')?.value,
        sound: document.getElementById('soundSelect')?.value,
        language: document.getElementById('languageSelect')?.value,
        notificationScale: parseFloat(document.getElementById('scaleSlider')?.value || 1),
        disableProgress: document.getElementById('disableProgressCheckbox')?.checked,
        windowZoomFactor: parseFloat(document.getElementById('app-zoom-dropdown')?.value || 1)
      };
      window.api.savePreferences(prefs);
      window.api.setZoom(prefs.windowZoomFactor); // setează zoom-ul live
    });
  }
});



window.addEventListener('DOMContentLoaded', () => {
const savedMessage = localStorage.getItem('configSavedMessage');
const success = localStorage.getItem('configSavedSuccess') === 'true';

if (savedMessage) {
showNotification(savedMessage, success ? '#4CAF50' : '#f44336');
localStorage.removeItem('configSavedMessage');
localStorage.removeItem('configSavedSuccess');
}
});

async function loadAndDisplayGameImage(appid, fallbackAppid = null) {
const toggleBtn = document.getElementById('toggleImageBtn');
const localImage = await window.api.checkLocalGameImage(appid);

if (localImage) {
document.getElementById('gameImage').src = `file://${localImage}`;
toggleBtn.textContent = '⇨ Hide Game Image';
return;
}

const url = `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${appid}/library_600x900.jpg`;

try {
const response = await fetch(url);
if (!response.ok) throw new Error('Image not found');
const blob = await response.blob();
const arrayBuffer = await blob.arrayBuffer();
await window.api.saveGameImage(appid, new Uint8Array(arrayBuffer));
const objectURL = URL.createObjectURL(blob);
document.getElementById('gameImage').src = objectURL;
toggleBtn.textContent = '⇨ Hide Game Image';
} catch (err) {
console.warn(`Image for AppID ${appid} not found.`, err);
if (fallbackAppid) {
loadAndDisplayGameImage(fallbackAppid);
} else {
document.getElementById('gameImage').src = 'https://cdn-icons-png.flaticon.com/512/11455/11455431.png';
}
}
}

function updateAchievementStats(achievements) {
const total = achievements.length;
const unlocked = achievements.filter(a => a.earned === true || a.earned === 1).length;

const label = document.getElementById('achStatsText');
const bar = document.getElementById('achStatsBar');
const percentLabel = document.getElementById('achStatsPercent');

const percentage = total > 0 ? Math.round((unlocked / total) * 100) : 0;

if (label && bar && percentLabel) {
label.textContent = `Progress: ${unlocked} / ${total}`;
bar.style.width = `${percentage}%`;
percentLabel.textContent = `${percentage}%`;
document.getElementById('achStats').style.display = 'block'; // ✅ asigurăm afișarea
}
}

window.api.on('auto-select-config', (configName) => {
const configList = document.getElementById('configList');
if (configList) {
configList.value = configName;
configList.dispatchEvent(new Event('change'));
}
});

async function reloadConfigsDropdown() {
  const configs = await window.api.loadConfigs();
  const dropdown = document.getElementById('configList');
  if (!dropdown) {
    console.error('⚠️ configList element not found.');
    return;
  }

  const selectedBefore = dropdown.value;

  dropdown.innerHTML = '';

  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = 'Select';
  defaultOption.disabled = true;
  defaultOption.selected = true;
  dropdown.appendChild(defaultOption);

  configs.forEach(config => {
    const option = document.createElement('option');
    option.value = config;
    option.textContent = config;
    dropdown.appendChild(option);
  });

  if (selectedBefore && configs.includes(selectedBefore)) {
    dropdown.value = selectedBefore;
    dropdown.querySelector('option[value=""]').selected = false;
  }
}


document.getElementById('generateConfigsBtn').addEventListener('click', async () => {
  const selectedFolder = await window.api.selectFolder();
  if (!selectedFolder) {
    alert('Canceled: You must select a save path folder to continue!');
    return;
  }

  const result = await window.autoConfigApi.generateConfigs(selectedFolder);
  if (result.success) {
    console.log('Configs generated successfully!');
	await reloadConfigsDropdown();
  } else {
    console.error('Failed to generate configs: ' + result.message);
  }
});

// Window control buttons
document.getElementById('minimizeBtn').addEventListener('click', () => {
  window.customApi.minimizeWindow();
});

document.getElementById('maximizeBtn').addEventListener('click', () => {
  window.customApi.maximizeWindow();
});

document.getElementById('closeBtn').addEventListener('click', () => {
  window.customApi.closeWindow();
});

// Update maximize button icon when window state changes
window.electron.ipcRenderer.on('window-state-change', (isMaximized) => {
  const maximizeBtn = document.getElementById('maximizeBtn');
  if (isMaximized) {
    maximizeBtn.innerHTML = '<i class="far fa-clone"></i>';
  } else {
    maximizeBtn.innerHTML = '<i class="far fa-square"></i>';
  }
});

// Add visual feedback when clicking buttons
const buttons = document.querySelectorAll('.titlebar-button');
buttons.forEach(button => {
  button.addEventListener('mousedown', () => {
    button.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
  });
  button.addEventListener('mouseup', () => {
    button.style.backgroundColor = '';
  });
  button.addEventListener('mouseleave', () => {
    button.style.backgroundColor = '';
  });
});

// Settings Menu Functionality
document.getElementById('settingsBtn').addEventListener('click', (event) => {
  event.stopPropagation();
  const settingsMenu = document.getElementById('settingsMenu');
  settingsMenu.classList.remove('hidden');
  
  // Sync settings values from main UI to settings menu
  syncSettingsToModal();
  
  // Set focus to the settings menu for keyboard accessibility
  setTimeout(() => {
    document.querySelector('.settings-content').focus();
  }, 10);
});

// Close settings menu with close button
document.getElementById('closeSettingsBtn').addEventListener('click', () => {
  const settingsMenu = document.getElementById('settingsMenu');
  settingsMenu.classList.add('hidden');
  syncSettingsFromModal();
});

// Click outside to close settings menu
document.getElementById('settingsMenu').addEventListener('click', (event) => {
  const settingsContent = document.querySelector('.settings-content');
  if (!settingsContent.contains(event.target)) {
    document.getElementById('settingsMenu').classList.add('hidden');
    syncSettingsFromModal();
  }
});

// Close settings menu with Escape key
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    const settingsMenu = document.getElementById('settingsMenu');
    if (!settingsMenu.classList.contains('hidden')) {
      settingsMenu.classList.add('hidden');
      syncSettingsFromModal();
    }
  }
});

// Tab switching
document.querySelectorAll('.settings-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    // Remove active class from all tabs
    document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    // Add active class to clicked tab and corresponding content
    tab.classList.add('active');
    const tabId = tab.getAttribute('data-tab');
    document.getElementById(tabId + 'Tab').classList.add('active');
  });
});

// Achievement test button in settings
document.getElementById('settings-testAchievementBtn').addEventListener('click', function() {
  const preset = document.getElementById('settings-presetDropdown').value || 'default';
  const position = document.getElementById('settings-positionDropdown').value;
  const sound = document.getElementById('settings-soundSelect').value;
  const scale = parseFloat(document.getElementById('settings-scaleSlider').value);
  
  window.api.showTestNotification({
    preset,
    position,
    sound,
    scale
  });
});

// Settings scale slider
const settingsScaleSlider = document.getElementById('settings-scaleSlider');
const settingsScaleValue = document.getElementById('settings-scaleValue');
const settingsScaleValueDisplay = document.getElementById('settings-scaleValueDisplay');

function updateSettingsScaleLabel() {
  const value = parseFloat(settingsScaleSlider.value);
  const percentage = Math.round(value * 100);
  settingsScaleValue.textContent = value.toFixed(2);
  settingsScaleValueDisplay.textContent = `${percentage}%`;
  settingsScaleSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, var(--dracula-cyan) ${percentage}%, #ccc ${percentage}%, #ccc 100%)`;
}

settingsScaleSlider.addEventListener('input', () => {
  updateSettingsScaleLabel();
  window.api.savePreferences({ notificationScale: settingsScaleSlider.value });
});

// Settings disable progress checkbox
document.getElementById('settings-disableProgressCheckbox').addEventListener('change', async (e) => {
  const isChecked = e.target.checked;
  window.api.disableProgress(isChecked);
  await window.api.savePreferences({ disableProgress: isChecked });
});

// Function to sync values between main UI and settings menu
function syncSettingsToModal() {
  // Copy preset options
  const mainPresetDropdown = document.getElementById('presetDropdown');
  const settingsPresetDropdown = document.getElementById('settings-presetDropdown');
  
  if (mainPresetDropdown && settingsPresetDropdown) {
    settingsPresetDropdown.innerHTML = mainPresetDropdown.innerHTML;
    if (mainPresetDropdown.value) {
      settingsPresetDropdown.value = mainPresetDropdown.value;
    }
  }
  
  // Copy sound options
  const mainSoundSelect = document.getElementById('soundSelect');
  const settingsSoundSelect = document.getElementById('settings-soundSelect');
  
  if (mainSoundSelect && settingsSoundSelect) {
    settingsSoundSelect.innerHTML = mainSoundSelect.innerHTML;
    if (mainSoundSelect.value) {
      settingsSoundSelect.value = mainSoundSelect.value;
    }
  }
  
  // Sync position dropdown
  const mainPositionDropdown = document.getElementById('positionDropdown');
  const settingsPositionDropdown = document.getElementById('settings-positionDropdown');
  
  if (mainPositionDropdown && settingsPositionDropdown) {
    settingsPositionDropdown.value = mainPositionDropdown.value;
  }
  
  // Sync scale slider
  const mainScaleSlider = document.getElementById('scaleSlider');
  const settingsScaleSlider = document.getElementById('settings-scaleSlider');
  
  if (mainScaleSlider && settingsScaleSlider) {
    settingsScaleSlider.value = mainScaleSlider.value;
    updateSettingsScaleLabel();
  }
  
  // Sync disable progress checkbox
  const mainDisableProgressCheckbox = document.getElementById('disableProgressCheckbox');
  const settingsDisableProgressCheckbox = document.getElementById('settings-disableProgressCheckbox');
  
  if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
    settingsDisableProgressCheckbox.checked = mainDisableProgressCheckbox.checked;
  }
}

function syncSettingsFromModal() {
  // Copy values from settings menu to main UI
  const mainPresetDropdown = document.getElementById('presetDropdown');
  const settingsPresetDropdown = document.getElementById('settings-presetDropdown');
  
  if (mainPresetDropdown && settingsPresetDropdown && settingsPresetDropdown.value) {
    mainPresetDropdown.value = settingsPresetDropdown.value;
  }
  
  // Copy sound options
  const mainSoundSelect = document.getElementById('soundSelect');
  const settingsSoundSelect = document.getElementById('settings-soundSelect');
  
  if (mainSoundSelect && settingsSoundSelect && settingsSoundSelect.value) {
    mainSoundSelect.value = settingsSoundSelect.value;
  }
  
  // Sync position dropdown
  const mainPositionDropdown = document.getElementById('positionDropdown');
  const settingsPositionDropdown = document.getElementById('settings-positionDropdown');
  
  if (mainPositionDropdown && settingsPositionDropdown) {
    mainPositionDropdown.value = settingsPositionDropdown.value;
  }
  
  // Sync scale slider
  const mainScaleSlider = document.getElementById('scaleSlider');
  const settingsScaleSlider = document.getElementById('settings-scaleSlider');
  
  if (mainScaleSlider && settingsScaleSlider) {
    mainScaleSlider.value = settingsScaleSlider.value;
    const event = new Event('input');
    mainScaleSlider.dispatchEvent(event);
  }
  
  // Sync disable progress checkbox
  const mainDisableProgressCheckbox = document.getElementById('disableProgressCheckbox');
  const settingsDisableProgressCheckbox = document.getElementById('settings-disableProgressCheckbox');
  
  if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
    mainDisableProgressCheckbox.checked = settingsDisableProgressCheckbox.checked;
  }
}

// Zoom level control
document.getElementById('app-zoom-dropdown').addEventListener('change', (e) => {
  const zoomValue = parseFloat(e.target.value);
  window.api.setZoom(zoomValue);
  window.api.savePreferences({ windowZoomFactor: zoomValue });
});

// Overlay shortcut functionality
const overlayShortcutBtn = document.getElementById('overlay-shortcut-btn');
let isListeningForShortcut = false;
let pressedKeys = new Set();
let shortcutTimeout;
let currentKeyHandler = null;

overlayShortcutBtn.addEventListener('click', () => {
  if (overlayShortcutBtn.textContent === 'Press keys...' || overlayShortcutBtn.classList.contains('listening')) {
    cleanupShortcutRecording();
    restoreSavedShortcutLabel();
    return;
  }

  overlayShortcutBtn.textContent = 'Press keys...';
  overlayShortcutBtn.classList.add('listening');
  isListeningForShortcut = true;
  pressedKeys.clear();

  const handleKeyDown = (e) => {
    if (!isListeningForShortcut) return;

    e.preventDefault();
    pressedKeys.add(e.key);

    clearTimeout(shortcutTimeout);
    shortcutTimeout = setTimeout(() => {
      if (!isListeningForShortcut) return;

      const keys = [];

      if (pressedKeys.has('Control')) keys.push('Control');
      if (pressedKeys.has('Shift')) keys.push('Shift');
      if (pressedKeys.has('Alt')) keys.push('Alt');

      const mainKeys = [...pressedKeys].filter(k => !['Control', 'Shift', 'Alt', 'Meta'].includes(k));
      if (mainKeys.length > 0) {
        const mainKey = mainKeys[0];
        keys.push(mainKey.length === 1 ? mainKey.toUpperCase() : mainKey);
      }

      if (keys.length < 2) {
        overlayShortcutBtn.textContent = 'Invalid combo';
        setTimeout(() => restoreSavedShortcutLabel(), 1200);
      } else {
        const combo = keys.join('+');
        overlayShortcutBtn.textContent = combo;
        window.api.savePreferences({ overlayShortcut: combo });
        window.api.updateOverlayShortcut?.(combo);
      }

      cleanupShortcutRecording();
    }, 400);
  };

  currentKeyHandler = handleKeyDown;
  document.addEventListener('keydown', handleKeyDown);
});

function cleanupShortcutRecording() {
  isListeningForShortcut = false;
  pressedKeys.clear();
  clearTimeout(shortcutTimeout);
  overlayShortcutBtn.classList.remove('listening');
  
  if (currentKeyHandler) {
    document.removeEventListener('keydown', currentKeyHandler);
    currentKeyHandler = null;
  }
}

async function restoreSavedShortcutLabel() {
  const prefs = await window.api.loadPreferences();
  overlayShortcutBtn.textContent = prefs?.overlayShortcut || 'Set Shortcut';
}

document.addEventListener('mousedown', (event) => {
  if (isListeningForShortcut && event.target !== overlayShortcutBtn) {
    cleanupShortcutRecording();
    restoreSavedShortcutLabel();
  }
});
</script>
</body>
</html>
